import unittest
import mock

from gant.ant_command import *

class TestAsyncCommandListener(unittest.TestCase):
    
    def test_on_message(self):
        cmd = mock.Mock()
        cmd.done = False
        l = AsyncCommandListener(cmd)
        l.on_message("dispatcher", (0x23, (1,2,3)))
        self.assertEquals("dispatcher", cmd.on_event.call_args[0][0].dispatcher)
        self.assertEquals(MessageType, cmd.on_event.call_args[0][1].type)
        self.assertEquals(0x23, cmd.on_event.call_args[0][1].msg_id)
        self.assertEquals((1,2,3), cmd.on_event.call_args[0][1].msg_args)
        self.assertTrue(l.on_message("dispatcher", (0x23, (1,2,3))) is not None)
        self.assertTrue(l.done is False)


class TestTreeAsyncCommand(unittest.TestCase):
    
    def test_root_listener(self):
        cmd = mock.Mock()
        cmd.done = False
        cmd.on_event.return_value = "test result"
        l = TreeAsyncCommand(cmd)
        # as long wrapped event does not return not, a value must be returned
        self.assertEquals(set(["test result"]), l.on_event(None, "test message"))
        self.assertTrue(l.done is False)

    def test_child_listener(self):
        root_cmd = mock.Mock()
        root_cmd.done = False
        child_cmd = mock.Mock()
        root_cmd.on_event.return_value = None
        child_cmd.on_event.return_value = "C"
        root_listener = TreeAsyncCommand(root_cmd)
        root_listener.add_command(child_cmd)
        # event "R" dispatched to child, which should replay with
        # "C" which is passed to root cmd which should reply None.
        # root returns None, but command should not return None, since a
        # child isn't ready for process to terminate yet.
        self.assertEquals(set(), root_listener.on_event(None, ("R")))
        # child invoked with original message
        self.assertEquals(1, child_cmd.on_event.call_count)
        self.assertEquals(
            "R",
            child_cmd.on_event.call_args[0][1])
        # root invoked with child result
        self.assertEquals(2, root_cmd.on_event.call_count)
        self.assertEquals(
            "R",
            root_cmd.on_event.call_args[0][1])

    def test_muliple_children(self):
        root_cmd = mock.Mock()
        root_cmd.done = False
        root_listener = TreeAsyncCommand(root_cmd)
        children = [mock.Mock() for n in range(0,5)]
        children[0].on_event.return_value = "1"
        children[1].on_event.return_value = "2"
        children[2].on_event.return_value = None 
        children[3].on_event.return_value = "3"
        children[4].on_event.return_value = "3"
        for c in children:
            root_listener.add_command(c)
        root_listener.on_event(None,"1") 
        # when the composite has muliple children all distinct
        # events generated by children must be dispatched
        self.assertEquals(3, root_cmd.on_event.call_count)
        self.assertEquals(
            "3",
            root_cmd.on_event.call_args[0][1])

    def test_remove_command(self):
        l = TreeAsyncCommand(None)
        c1 = mock.Mock()
        c2 = mock.Mock()
        l.add_command(c1)
        self.assertEquals(1, len(l.children))
        l.remove_command(c2)
        self.assertEquals(1, len(l.children))
        l.remove_command(c1)
        self.assertEquals(0, len(l.children))

    def test_child_requests_removal(self):
        root_cmd = mock.Mock()
        child_cmd = mock.Mock()
        child_cmd.done = False
        l = TreeAsyncCommand(root_cmd)
        def on_event(ctx, event):
            child_cmd.done = True
            return "foo"
        child_cmd.on_event = on_event
        l.add_command(child_cmd)
        l.on_event(None, None)
        self.assertEquals(0, len(l.children))
        

# vim: et ts=4 sts=4
